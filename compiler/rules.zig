// This will be autogenerated as soon as the compiler works
const std = @import("std");
const pag = @import("pag");

const Allocator = std.mem.Allocator;
const ast = @import("ast.zig");

usingnamespace struct {
    pub const file: pag.Rule = &.{
        .{ .syms = &.{ .{ .nt = .ws }, .{ .nt = .rule }, .{ .nt = .file } }, .func = funcs.file0 },
        .{ .syms = &.{ .{ .nt = .ws }, .end }, .func = funcs.file1 },
    };

    pub const rule: pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .ident },
            .{ .nt = .ws },
            .{ .str = "=" },
            .{ .nt = .ws },
            .{ .nt = .productions },
            .{ .nt = .ws },
            .{ .str = ";" },
        }, .func = funcs.rule0 },
    };
    pub const productions: pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .production },
            .{ .nt = .ws },
            .{ .str = "|" },
            .{ .nt = .ws },
            .{ .nt = .productions },
        }, .func = funcs.productions0 },
        .{ .syms = &.{.{ .nt = .production }}, .func = funcs.productions1 },
    };
    pub const production: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .symbols }, .{ .nt = .ws }, .{ .nt = .func } },
            .func = funcs.production0,
        },
    };
    pub const symbols: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .symbol }, .{ .nt = .ws }, .{ .nt = .symbols } },
            .func = funcs.symbols0,
        },
        .{ .syms = &.{}, .func = funcs.symbols1 },
    };
    pub const symbol: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .ident }}, .func = funcs.symbol0 },
        .{ .syms = &.{.{ .nt = .string }}, .func = funcs.symbol1 },
        .{ .syms = &.{.{ .nt = .set }}, .func = funcs.symbol2 },
        .{ .syms = &.{.{ .nt = .end }}, .func = funcs.symbol3 },
    };

    pub const func: pag.Rule = &.{
        .{ .syms = &.{ .{ .str = "@" }, .{ .nt = .zig_ident } }, .func = funcs.func0 },
        .{ .syms = &.{}, .func = funcs.func1 },
    };
    pub const zig_ident: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .zig_ident_first_char }, .{ .nt = .zig_ident_rest } },
            .func = funcs.ArrayBuilder(u8).build,
        },
    };
    pub const zig_ident_rest: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .zig_ident_char }, .{ .nt = .zig_ident_rest } },
            .func = funcs.ArrayBuilder(u8).build,
        },
        .{
            .syms = &.{},
            .func = funcs.ArrayBuilder(u8).empty,
        },
    };
    pub const zig_ident_first_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .add("_")
                .set },
        }, .func = funcs.char },
    };
    pub const zig_ident_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .addRange('0', '9')
                .add("_")
                .set },
        }, .func = funcs.char },
    };

    pub const ident: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .ident_rev }}, .func = funcs.ArrayBuilder(u8).finish },
    };
    pub const ident_rev: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .ident_char }, .{ .nt = .ident_rev } },
            .func = funcs.ArrayBuilder(u8).build,
        },
        .{ .syms = &.{.{ .nt = .ident_char }}, .func = funcs.ArrayBuilder(u8).one },
    };
    pub const ident_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .addRange('0', '9')
                .add("?!_-")
                .set },
        }, .func = funcs.char },
    };

    pub const string: pag.Rule = &.{
        .{
            .syms = &.{ .{ .str = "\"" }, .{ .nt = .string_chars }, .{ .str = "\"" } },
            .func = funcs.string0,
        },
    };
    pub const string_chars: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .string_char }, .{ .nt = .string_chars } },
            .func = funcs.ArrayBuilder(u8).build,
        },
        .{ .syms = &.{}, .func = funcs.ArrayBuilder(u8).empty },
    };
    pub const string_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\\"")
                .invert()
                .set },
        }, .func = funcs.char },
        .{ .syms = &.{
            .{ .str = "\\" },
            .{ .nt = .string_char_escaped },
        }, .func = funcs.string_char1 },
    };
    pub const string_char_escaped: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\\"")
                .set },
        }, .func = funcs.char },
        .{ .syms = &.{
            .{ .str = "x" },
            .{ .nt = .hexdig },
            .{ .nt = .hexdig },
        }, .func = funcs.string_char_escaped1 },
    };

    pub const set: pag.Rule = &.{
        .{
            .syms = &.{
                .{ .str = "[" },
                .{ .nt = .set_invert },
                .{ .nt = .set_entries },
                .{ .str = "]" },
            },
            .func = funcs.set0,
        },
    };
    pub const set_invert: pag.Rule = &.{
        .{ .syms = &.{.{ .str = "^" }}, .func = funcs.set_invert0 },
        .{ .syms = &.{}, .func = funcs.set_invert1 },
    };
    pub const set_entries: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .set_entry }, .{ .nt = .set_entries } },
            .func = funcs.ArrayBuilder(ast.Set.Entry).build,
        },
        .{ .syms = &.{.{ .nt = .set_entry }}, .func = funcs.ArrayBuilder(ast.Set.Entry).one },
    };
    pub const set_entry: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .set_char }, .{ .str = "-" }, .{ .nt = .set_char } },
            .func = funcs.set_entry0,
        },
        .{ .syms = &.{.{ .nt = .set_char }}, .func = funcs.set_entry1 },
    };
    pub const set_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("[]\\")
                .invert()
                .set },
        }, .func = funcs.char },
        .{ .syms = &.{
            .{ .str = "\\" },
            .{ .nt = .set_char_escaped },
        }, .func = funcs.string_char1 },
    };
    pub const set_char_escaped: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("[]\\")
                .set },
        }, .func = funcs.char },
        .{ .syms = &.{
            .{ .str = "x" },
            .{ .nt = .hexdig },
            .{ .nt = .hexdig },
        }, .func = funcs.string_char_escaped1 },
    };

    pub const ws: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add(" \t\n")
                .set },
            .{ .nt = .ws },
        } },
        .{ .syms = &.{
            .{ .str = "//" },
            .{ .nt = .comment },
            .{ .str = "\n" },
            .{ .nt = .ws },
        } },
        .{ .syms = &.{} },
    };
    pub const comment: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\n")
                .invert()
                .set },
            .{ .nt = .comment },
        } },
        .{ .syms = &.{} },
    };

    pub const hexdig: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('0', '9')
                .addRange('a', 'f')
                .addRange('A', 'F')
                .set },
        }, .func = funcs.hexdig },
    };

    pub const end: pag.Rule = &.{.{ .syms = &.{.{ .str = "$" }} }};
};

const funcs = struct {
    fn file0(
        allocator: Allocator,
        _: void,
        rule: ast.Rule,
        rest: ?ast.List(ast.Rule),
    ) !?ast.List(ast.Rule) {
        return try ast.List(ast.Rule).initAlloc(allocator, rule, rest);
    }
    fn file1(_: Allocator, _: void, _: void) ?ast.List(ast.Rule) {
        return null;
    }

    fn rule0(
        allocator: Allocator,
        name: []const u8,
        _: void,
        _: []const u8,
        _: void,
        prods: ast.List(ast.Production),
        _: void,
        _: []const u8,
    ) !ast.Rule {
        return ast.Rule{
            .name = name,
            .prods = try ast.List(ast.Production).collect(prods, allocator),
        };
    }

    fn productions0(
        allocator: Allocator,
        prod: ast.Production,
        _: void,
        _: []const u8,
        _: void,
        rest: ast.List(ast.Production),
    ) !ast.List(ast.Production) {
        return try ast.List(ast.Production).initAlloc(allocator, prod, rest);
    }
    fn productions1(_: Allocator, prod: ast.Production) ast.List(ast.Production) {
        return .{ .value = prod };
    }

    fn production0(
        allocator: Allocator,
        syms: ?ast.List(ast.Symbol),
        _: void,
        func: ?[]const u8,
    ) !ast.Production {
        return ast.Production{
            .syms = try ast.List(ast.Symbol).collect(syms, allocator),
            .func = func,
        };
    }

    fn symbols0(
        allocator: Allocator,
        sym: ast.Symbol,
        _: void,
        rest: ?ast.List(ast.Symbol),
    ) !?ast.List(ast.Symbol) {
        return try ast.List(ast.Symbol).initAlloc(allocator, sym, rest);
    }
    fn symbols1(_: Allocator) ?ast.List(ast.Symbol) {
        return null;
    }
    fn symbol0(_: Allocator, ident: []const u8) ast.Symbol {
        return .{ .nt = ident };
    }
    fn symbol1(_: Allocator, string: []const u8) ast.Symbol {
        return .{ .str = string };
    }
    fn symbol2(_: Allocator, set: ast.Set) ast.Symbol {
        return .{ .set = set };
    }
    fn symbol3(_: Allocator, _: void) ast.Symbol {
        return .end;
    }

    fn func0(allocator: Allocator, _: []const u8, ident: std.ArrayListUnmanaged(u8)) ?[]const u8 {
        return ArrayBuilder(u8).finish(allocator, ident);
    }
    fn func1(_: Allocator) ?[]const u8 {
        return null;
    }

    fn string0(
        allocator: Allocator,
        _: []const u8,
        str: std.ArrayListUnmanaged(u8),
        _: []const u8,
    ) []const u8 {
        return ArrayBuilder(u8).finish(allocator, str);
    }
    fn string_char1(_: Allocator, _: []const u8, ch: u8) u8 {
        return ch;
    }
    fn string_char_escaped1(_: Allocator, _: []const u8, d0: u4, d1: u4) u8 {
        return (@as(u8, d0) << 4) | d1;
    }

    fn set0(
        allocator: Allocator,
        _: []const u8,
        invert: bool,
        entries: std.ArrayListUnmanaged(ast.Set.Entry),
        _: []const u8,
    ) ast.Set {
        return .{
            .entries = ArrayBuilder(ast.Set.Entry).finish(allocator, entries),
            .invert = invert,
        };
    }
    fn set_invert0(_: Allocator, _: []const u8) bool {
        return true;
    }
    fn set_invert1(_: Allocator) bool {
        return false;
    }
    fn set_entry0(_: Allocator, start: u8, _: []const u8, end: u8) ast.Set.Entry {
        return .{ .range = .{
            .start = start,
            .end = end,
        } };
    }
    fn set_entry1(_: Allocator, ch: u8) ast.Set.Entry {
        return .{ .ch = ch };
    }

    fn char(_: Allocator, ch: u8) u8 {
        return ch;
    }

    fn ArrayBuilder(comptime T: type) type {
        return struct {
            fn build(
                allocator: Allocator,
                elem: T,
                array: std.ArrayListUnmanaged(T),
            ) !std.ArrayListUnmanaged(T) {
                var array_var = array;
                try array_var.append(allocator, elem);
                return array_var;
            }
            fn empty(_: Allocator) std.ArrayListUnmanaged(T) {
                return .{};
            }
            fn one(allocator: Allocator, elem: T) !std.ArrayListUnmanaged(T) {
                return build(allocator, elem, .{});
            }
            fn finish(allocator: Allocator, array: std.ArrayListUnmanaged(T)) []const T {
                var array_var = array;
                std.mem.reverse(T, array_var.items);
                return array_var.toOwnedSlice(allocator);
            }
        };
    }

    fn hexdig(_: Allocator, ch: u8) u4 {
        const dig = switch (ch) {
            '0'...'9' => ch - '0',
            'a'...'f' => ch - 'a' + 0xa,
            'A'...'F' => ch - 'A' + 0xa,
            else => unreachable,
        };
        return @intCast(u4, dig);
    }
};
