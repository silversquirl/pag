// This will be autogenerated as soon as the compiler works
const std = @import("std");
const pag = @import("pag");

const Allocator = std.mem.Allocator;
const ast = @import("ast.zig");

usingnamespace struct {
    pub const file: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .ws }, .{ .nt = .toplevel }, .{ .nt = .file } },
            .handler = struct {
                pub const match = funcs.file0;
            },
        },
        .{ .syms = &.{ .{ .nt = .ws }, .end }, .handler = struct {
            pub const match = funcs.file1;
        } },
    };
    pub const toplevel: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .pragma }}, .handler = struct {
            pub const match = funcs.toplevel0;
        } },
        .{ .syms = &.{.{ .nt = .block }}, .handler = struct {
            pub const match = funcs.toplevel1;
        } },
        .{ .syms = &.{.{ .nt = .rule }}, .handler = struct {
            pub const match = funcs.toplevel2;
        } },
    };

    pub const pragma: pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = "#context" },
            .{ .nt = .required_ws },
            .{ .nt = .@"zig-ident" },
            .{ .nt = .ws },
            .{ .str = ":" },
            .{ .nt = .ws },
            .{ .nt = .@"zig-type" },
            .{ .nt = .ws },
            .{ .str = ";" },
        }, .handler = struct {
            pub const match = funcs.pragma0;
        } },
    };

    pub const block: pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = "{" },
            .{ .nt = .@"zig-code" },
            .{ .str = "}" },
        }, .handler = struct {
            pub const match = funcs.block0;
        } },
    };

    pub const @"zig-code": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-code-el" },
            .{ .nt = .@"zig-code" },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).extend;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).empty;
        } },
    };

    pub const @"zig-code-el": pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\"")
                .add("{")
                .add("}")
                .invert()
                .set },
        }, .handler = struct {
            pub const match = funcs.zig_code_el0;
        } },
        .{ .syms = &.{
            .{ .nt = .@"zig-string" },
        }, .handler = struct {
            pub const match = funcs.zig_code_el1;
        } },
        .{ .syms = &.{
            .{ .nt = .block },
        }, .handler = struct {
            pub const match = funcs.zig_code_el2;
        } },
    };

    pub const @"zig-string": pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = "\"" },
            .{ .nt = .@"zig-ds-chars" },
            .{ .str = "\"" },
        }, .handler = struct {
            pub const match = funcs.zig_string;
        } },
        .{ .syms = &.{
            .{ .str = "'" },
            .{ .nt = .@"zig-ss-chars" },
            .{ .str = "'" },
        }, .handler = struct {
            pub const match = funcs.zig_string;
        } },
    };

    pub const @"zig-ds-chars": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-ds-char" },
            .{ .nt = .@"zig-ds-chars" },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).build;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).empty;
        } },
    };

    pub const @"zig-ss-chars": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-ss-char" },
            .{ .nt = .@"zig-ss-chars" },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).build;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).empty;
        } },
    };

    pub const @"zig-ds-char": pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\")
                .add("\"")
                .invert()
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .nt = .@"zig-char-escaped" },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
    };

    pub const @"zig-ss-char": pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\")
                .add("'")
                .invert()
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .nt = .@"zig-char-escaped" },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
    };

    pub const @"zig-char-escaped": pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = "\\" },
            .{ .set = &pag.SetBuilder.init()
                .addRange('\x00', '\xff')
                .set },
        }, .handler = struct {
            pub const match = funcs.string_char1;
        } },
    };

    pub const rule: pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .ident },
            .{ .nt = .ws },
            .{ .nt = .@"type-annotation?" },
            .{ .nt = .ws },
            .{ .str = "=" },
            .{ .nt = .ws },
            .{ .nt = .productions },
            .{ .nt = .ws },
            .{ .str = ";" },
        }, .handler = struct {
            pub const match = funcs.rule0;
        } },
    };
    pub const productions: pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .production },
            .{ .nt = .ws },
            .{ .str = "|" },
            .{ .nt = .ws },
            .{ .nt = .productions },
        }, .handler = struct {
            pub const match = funcs.productions0;
        } },
        .{ .syms = &.{
            .{ .nt = .production },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder(ast.Production).one;
        } },
    };
    pub const production: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .symbols }, .{ .nt = .ws }, .{ .nt = .@"func?" } },
            .handler = struct {
                pub const match = funcs.production0;
            },
        },
    };
    pub const symbols: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .symbol }, .{ .nt = .ws }, .{ .nt = .symbols } },
            .handler = struct {
                pub const match = funcs.symbols0;
            },
        },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.symbols1;
        } },
    };
    pub const symbol: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .ident }}, .handler = struct {
            pub const match = funcs.symbol0;
        } },
        .{ .syms = &.{.{ .nt = .string }}, .handler = struct {
            pub const match = funcs.symbol1;
        } },
        .{ .syms = &.{.{ .nt = .set }}, .handler = struct {
            pub const match = funcs.symbol2;
        } },
        .{ .syms = &.{.{ .nt = .end }}, .handler = struct {
            pub const match = funcs.symbol3;
        } },
    };

    pub const @"func?": pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = "@" },
            .{ .nt = .ws },
            .{ .str = "(" },
            .{ .nt = .ws },
            .{ .nt = .args },
            .{ .nt = .ws },
            .{ .str = ")" },
            .{ .nt = .ws },
            .{ .nt = .block },
        }, .handler = struct {
            pub const match = funcs.func0;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.func1;
        } },
    };

    pub const args: pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-ident" },
            .{ .nt = .ws },
            .{ .str = "," },
            .{ .nt = .ws },
            .{ .nt = .args },
        }, .handler = struct {
            pub const match = funcs.args0;
        } },
        .{ .syms = &.{
            .{ .nt = .@"zig-ident" },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder([]const u8).one;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder([]const u8).empty;
        } },
    };

    pub const @"zig-ident": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-ident-first-char" },
            .{ .nt = .@"zig-ident-rest" },
        }, .handler = struct {
            pub const match = funcs.zig_ident0;
        } },
    };

    pub const @"zig-ident-rest": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .@"zig-ident-char" },
            .{ .nt = .@"zig-ident-rest" },
        }, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).build;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).empty;
        } },
    };

    pub const @"zig-ident-first-char": pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .add("_")
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
    };

    pub const @"zig-ident-char": pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .addRange('0', '9')
                .add("_")
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
    };

    pub const @"type-annotation?": pag.Rule = &.{
        .{ .syms = &.{
            .{ .str = ":" },
            .{ .nt = .ws },
            .{ .nt = .@"zig-type" },
        }, .handler = struct {
            pub const match = funcs.type_annotation0;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.type_annotation1;
        } },
    };

    pub const @"zig-type": pag.Rule = &.{
        .{ .syms = &.{
            .{ .nt = .block },
        }, .handler = struct {
            pub const match = funcs.zig_type0;
        } },
    };

    pub const ident: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .ident_rev }}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).finish;
        } },
    };
    pub const ident_rev: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .ident_char }, .{ .nt = .ident_rev } },
            .handler = struct {
                pub const match = funcs.ArrayBuilder(u8).build;
            },
        },
        .{ .syms = &.{.{ .nt = .ident_char }}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).one;
        } },
    };
    pub const ident_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('a', 'z')
                .addRange('A', 'Z')
                .addRange('0', '9')
                .add("?!_-")
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
    };

    pub const string: pag.Rule = &.{
        .{
            .syms = &.{ .{ .str = "\"" }, .{ .nt = .string_chars }, .{ .str = "\"" } },
            .handler = struct {
                pub const match = funcs.string0;
            },
        },
    };
    pub const string_chars: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .string_char }, .{ .nt = .string_chars } },
            .handler = struct {
                pub const match = funcs.ArrayBuilder(u8).build;
            },
        },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.ArrayBuilder(u8).empty;
        } },
    };
    pub const string_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\\"")
                .invert()
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .str = "\\" },
            .{ .nt = .string_char_escaped },
        }, .handler = struct {
            pub const match = funcs.string_char1;
        } },
    };
    pub const string_char_escaped: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\\\"")
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .str = "x" },
            .{ .nt = .hexdig },
            .{ .nt = .hexdig },
        }, .handler = struct {
            pub const match = funcs.string_char_escaped1;
        } },
    };

    pub const set: pag.Rule = &.{
        .{
            .syms = &.{
                .{ .str = "[" },
                .{ .nt = .set_invert },
                .{ .nt = .set_entries },
                .{ .str = "]" },
            },
            .handler = struct {
                pub const match = funcs.set0;
            },
        },
    };
    pub const set_invert: pag.Rule = &.{
        .{ .syms = &.{.{ .str = "^" }}, .handler = struct {
            pub const match = funcs.set_invert0;
        } },
        .{ .syms = &.{}, .handler = struct {
            pub const match = funcs.set_invert1;
        } },
    };
    pub const set_entries: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .set_entry }, .{ .nt = .set_entries } },
            .handler = struct {
                pub const match = funcs.ArrayBuilder(ast.Set.Entry).build;
            },
        },
        .{ .syms = &.{.{ .nt = .set_entry }}, .handler = struct {
            pub const match = funcs.ArrayBuilder(ast.Set.Entry).one;
        } },
    };
    pub const set_entry: pag.Rule = &.{
        .{
            .syms = &.{ .{ .nt = .set_char }, .{ .str = "-" }, .{ .nt = .set_char } },
            .handler = struct {
                pub const match = funcs.set_entry0;
            },
        },
        .{ .syms = &.{.{ .nt = .set_char }}, .handler = struct {
            pub const match = funcs.set_entry1;
        } },
    };
    pub const set_char: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("[]\\")
                .invert()
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .str = "\\" },
            .{ .nt = .set_char_escaped },
        }, .handler = struct {
            pub const match = funcs.string_char1;
        } },
    };
    pub const set_char_escaped: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("[]\\")
                .set },
        }, .handler = struct {
            pub const match = funcs.char;
        } },
        .{ .syms = &.{
            .{ .str = "x" },
            .{ .nt = .hexdig },
            .{ .nt = .hexdig },
        }, .handler = struct {
            pub const match = funcs.string_char_escaped1;
        } },
    };

    pub const ws: pag.Rule = &.{
        .{ .syms = &.{.{ .nt = .required_ws }} },
        .{ .syms = &.{} },
    };
    pub const required_ws: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add(" \t\n")
                .set },
            .{ .nt = .ws },
        } },
        .{ .syms = &.{
            .{ .str = "//" },
            .{ .nt = .comment },
            .{ .str = "\n" },
            .{ .nt = .ws },
        } },
    };
    pub const comment: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .add("\n")
                .invert()
                .set },
            .{ .nt = .comment },
        } },
        .{ .syms = &.{} },
    };

    pub const hexdig: pag.Rule = &.{
        .{ .syms = &.{
            .{ .set = &pag.SetBuilder.init()
                .addRange('0', '9')
                .addRange('a', 'f')
                .addRange('A', 'F')
                .set },
        }, .handler = struct {
            pub const match = funcs.hexdig;
        } },
    };

    pub const end: pag.Rule = &.{.{ .syms = &.{.{ .str = "$" }} }};
};

const funcs = struct {
    fn file0(
        allocator: Allocator,
        _: void,
        tl: ast.Toplevel,
        rest: std.ArrayListUnmanaged(ast.Toplevel),
    ) !std.ArrayListUnmanaged(ast.Toplevel) {
        return ArrayBuilder(ast.Toplevel).build(allocator, tl, rest);
    }
    fn file1(allocator: Allocator, _: void, _: void) std.ArrayListUnmanaged(ast.Toplevel) {
        return ArrayBuilder(ast.Toplevel).empty(allocator);
    }

    fn toplevel0(_: Allocator, pragma: ast.Pragma) ast.Toplevel {
        return .{ .pragma = pragma };
    }
    fn toplevel1(_: Allocator, block: []const u8) ast.Toplevel {
        return .{ .block = block };
    }
    fn toplevel2(_: Allocator, rule: ast.Rule) ast.Toplevel {
        return .{ .rule = rule };
    }

    fn pragma0(
        _: Allocator,
        _: []const u8,
        _: void,
        name: []const u8,
        _: void,
        _: []const u8,
        _: void,
        ty: []const u8,
        _: void,
        _: []const u8,
    ) ast.Pragma {
        return .{ .context = .{
            .name = name,
            .type = ty,
        } };
    }

    fn block0(
        allocator: Allocator,
        _: []const u8,
        code: std.ArrayListUnmanaged(u8),
        _: []const u8,
    ) []const u8 {
        return ArrayBuilder(u8).finish(allocator, code);
    }
    fn zig_code_el0(allocator: Allocator, ch: u8) ![]const u8 {
        const str = try allocator.alloc(u8, 1);
        str[0] = ch;
        return str;
    }
    fn zig_code_el1(_: Allocator, str: []const u8) []const u8 {
        return str;
    }
    fn zig_code_el2(allocator: Allocator, str: []const u8) ![]const u8 {
        var array = try std.ArrayList(u8).initCapacity(allocator, str.len + 2);
        array.appendAssumeCapacity('{');
        array.appendSliceAssumeCapacity(str);
        array.appendAssumeCapacity('}');
        allocator.free(str);
        return array.toOwnedSlice();
    }
    fn zig_string(
        allocator: Allocator,
        delim0: []const u8,
        str: std.ArrayListUnmanaged(u8),
        delim1: []const u8,
    ) ![]const u8 {
        var str_var = str;
        try str_var.insertSlice(allocator, 0, delim0);
        try str_var.appendSlice(allocator, delim1);
        return ArrayBuilder(u8).finish(allocator, str_var);
    }

    fn rule0(
        allocator: Allocator,
        name: []const u8,
        _: void,
        result_type: ?[]const u8,
        _: void,
        _: []const u8,
        _: void,
        prods: std.ArrayListUnmanaged(ast.Production),
        _: void,
        _: []const u8,
    ) !ast.Rule {
        return ast.Rule{
            .name = name,
            .type = result_type orelse "void",
            .prods = ArrayBuilder(ast.Production).finish(allocator, prods),
        };
    }

    fn productions0(
        allocator: Allocator,
        prod: ast.Production,
        _: void,
        _: []const u8,
        _: void,
        rest: std.ArrayListUnmanaged(ast.Production),
    ) !std.ArrayListUnmanaged(ast.Production) {
        return ArrayBuilder(ast.Production).build(allocator, prod, rest);
    }
    fn productions1(_: Allocator, prod: ast.Production) ast.List(ast.Production) {
        return .{ .value = prod };
    }

    fn production0(
        allocator: Allocator,
        syms_list: ?ast.List(ast.Symbol),
        _: void,
        func: ?ast.Func,
    ) !ast.Production {
        const syms = try ast.List(ast.Symbol).collect(syms_list, allocator);
        if (func != null and syms.len != func.?.args.len) {
            return error.InvalidArity;
        }
        return ast.Production{ .syms = syms, .func = func };
    }

    fn symbols0(
        allocator: Allocator,
        sym: ast.Symbol,
        _: void,
        rest: ?ast.List(ast.Symbol),
    ) !?ast.List(ast.Symbol) {
        return try ast.List(ast.Symbol).initAlloc(allocator, sym, rest);
    }
    fn symbols1(_: Allocator) ?ast.List(ast.Symbol) {
        return null;
    }
    fn symbol0(_: Allocator, ident: []const u8) ast.Symbol {
        return .{ .nt = ident };
    }
    fn symbol1(_: Allocator, string: []const u8) ast.Symbol {
        return .{ .str = string };
    }
    fn symbol2(_: Allocator, set: ast.Set) ast.Symbol {
        return .{ .set = set };
    }
    fn symbol3(_: Allocator, _: void) ast.Symbol {
        return .end;
    }

    fn func0(
        allocator: Allocator,
        _: []const u8,
        _: void,
        _: []const u8,
        _: void,
        args: std.ArrayListUnmanaged([]const u8),
        _: void,
        _: []const u8,
        _: void,
        block: []const u8,
    ) ?ast.Func {
        return ast.Func{
            .args = ArrayBuilder([]const u8).finish(allocator, args),
            .code = block,
        };
    }
    fn func1(_: Allocator) ?ast.Func {
        return null;
    }

    fn zig_ident0(
        allocator: Allocator,
        first_char: u8,
        rest: std.ArrayListUnmanaged(u8),
    ) ![]const u8 {
        const id = try ArrayBuilder(u8).build(allocator, first_char, rest);
        return ArrayBuilder(u8).finish(allocator, id);
    }

    fn args0(
        allocator: Allocator,
        ident: []const u8,
        _: void,
        _: []const u8,
        _: void,
        rest: std.ArrayListUnmanaged([]const u8),
    ) !std.ArrayListUnmanaged([]const u8) {
        return ArrayBuilder([]const u8).build(allocator, ident, rest);
    }

    fn type_annotation0(_: Allocator, _: []const u8, _: void, ty: []const u8) ?[]const u8 {
        return ty;
    }
    fn type_annotation1(_: Allocator) ?[]const u8 {
        return null;
    }
    fn zig_type0(_: Allocator, ty: []const u8) []const u8 {
        return ty;
    }

    fn string0(
        allocator: Allocator,
        _: []const u8,
        str: std.ArrayListUnmanaged(u8),
        _: []const u8,
    ) []const u8 {
        return ArrayBuilder(u8).finish(allocator, str);
    }
    fn string_char1(_: Allocator, _: []const u8, ch: u8) u8 {
        return ch;
    }
    fn string_char_escaped1(_: Allocator, _: []const u8, d0: u4, d1: u4) u8 {
        return (@as(u8, d0) << 4) | d1;
    }

    fn set0(
        allocator: Allocator,
        _: []const u8,
        invert: bool,
        entries: std.ArrayListUnmanaged(ast.Set.Entry),
        _: []const u8,
    ) ast.Set {
        return .{
            .entries = ArrayBuilder(ast.Set.Entry).finish(allocator, entries),
            .invert = invert,
        };
    }
    fn set_invert0(_: Allocator, _: []const u8) bool {
        return true;
    }
    fn set_invert1(_: Allocator) bool {
        return false;
    }
    fn set_entry0(_: Allocator, start: u8, _: []const u8, end: u8) ast.Set.Entry {
        return .{ .range = .{
            .start = start,
            .end = end,
        } };
    }
    fn set_entry1(_: Allocator, ch: u8) ast.Set.Entry {
        return .{ .ch = ch };
    }

    fn char(_: Allocator, ch: u8) u8 {
        return ch;
    }

    fn ArrayBuilder(comptime T: type) type {
        return struct {
            fn build(
                allocator: Allocator,
                elem: T,
                array: std.ArrayListUnmanaged(T),
            ) !std.ArrayListUnmanaged(T) {
                var array_var = array;
                try array_var.append(allocator, elem);
                return array_var;
            }
            fn extend(
                allocator: Allocator,
                elems: []const T,
                array: std.ArrayListUnmanaged(T),
            ) !std.ArrayListUnmanaged(T) {
                var array_var = array;
                try array_var.appendSlice(allocator, elems);
                std.mem.reverse(T, array_var.items[array.items.len..]);
                allocator.free(elems);
                return array_var;
            }
            fn empty(_: Allocator) std.ArrayListUnmanaged(T) {
                return .{};
            }
            fn one(allocator: Allocator, elem: T) !std.ArrayListUnmanaged(T) {
                return build(allocator, elem, .{});
            }
            fn finish(allocator: Allocator, array: std.ArrayListUnmanaged(T)) []const T {
                var array_var = array;
                std.mem.reverse(T, array_var.items);
                return array_var.toOwnedSlice(allocator);
            }
        };
    }

    fn hexdig(_: Allocator, ch: u8) u4 {
        const dig = switch (ch) {
            '0'...'9' => ch - '0',
            'a'...'f' => ch - 'a' + 0xa,
            'A'...'F' => ch - 'A' + 0xa,
            else => unreachable,
        };
        return @intCast(u4, dig);
    }
};
